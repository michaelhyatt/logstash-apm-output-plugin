input {
  # generator { message => "Hello world!" count => 10 }
  elasticsearch {
    hosts => "localhost"
    index => "anz-*"
    query => '{ "query": { "match": { "jobId": "5c2b73df-3338-44bd-a96c-fad2a1b00495" } }, "sort": [ {"@timestamp": {"order": "asc"}} ] }'
    size => 1000
    # schedule => "* * * * *"
  }
}

filter {

  # add mandatory apm_id field
  mutate {
    add_field => { "apm_id" => "%{jobId}" }
  }

  # 1. parse and create apm_command field for 4 variables:
    # TRANSACTION_START
    # SPAN_START
    # SPAN_END
    # TRANSACTION_END
  # 2. Get apm_name as transaction or span name
  # 3. Get apm_timestamp
  ruby {
    code => "event.set('apm_timestamp', event.get('@timestamp'))"
  }

  if [message] =~ "\S execution started" {

    mutate {
      add_field => { "apm_command" => "TRANSACTION_START"}
    }

    grok {
      match => { "message" => "%{DATA:apm_name} execution started" }
    }
  } else
  if [message] =~ "\S execution ended" {

    mutate {
      add_field => { "apm_command" => "TRANSACTION_END"}
    }

    grok {
      match => { "message" => "%{DATA:apm_name} execution ended" }
    }
  } else
  if [message] =~ "\S Executing" {

    mutate {
      add_field => { "apm_command" => "SPAN_START"}
    }

    grok {
      match => { "message" => "%{DATA:apm_name} Executing" }
    }
  } else
  if [message] =~ "\S Closed" {

    mutate {
      add_field => { "apm_command" => "SPAN_END"}
    }

    grok {
      match => { "message" => "%{DATA:apm_name} Closed" }
    }
  }

  # Ignore everything else
  else {
    drop {}
  }
}

output {
  # stdout { codec => rubydebug }
  elastic_apm_server {
    server_urls => "http://localhost:8200"
    service_name => "uipath"
    log_level => "DEBUG"
  }
}
